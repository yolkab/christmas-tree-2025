<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>沉浸式粒子圣诞树</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Brush Script MT', cursive, sans-serif;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ui-header {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #FFD700; /* 金色 */
            font-size: 3em;
            text-shadow: 0 0 10px #FFD700, 0 0 20px #ff8c00;
            pointer-events: none;
            z-index: 10;
        }
        /* 隐藏文件输入框 */
        #file-input { display: none; }
        /* 视频用于MediaPipe，隐藏 */
        #input-video { display: none; }
        /* 加载提示 */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="ui-header">Merry Christmas！</div>
    <div id="loading">正在加载魔法引擎 (MediaPipe)...</div>
    <div id="canvas-container"></div>
    <video id="input-video"></video>
    <input type="file" id="file-input" accept="image/*">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        let scene, camera, renderer, clock;
        let treeParticles, snowParticles, starField;
        let treeUniforms;
        let isHandOpen = false;
        let handRotationTarget = { x: 0, y: 0 };
        let treeGroup = new THREE.Group();
        let decorationsGroup = new THREE.Group();
        let floatingPhotosGroup = new THREE.Group();
        let slideshowTextures = [];
        let currentSlideIndex = 0;
        let lastSlideChangeTime = 0;

        const TOTAL_TREE_PARTICLES = 15000;
        const TREE_HEIGHT = 15;
        const TREE_RADIUS = 6;

        init();
        setupMediaPipe();
        setupKeyboard();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');
            clock = new THREE.Clock();

            scene = new THREE.Scene();
            // 雾化效果增强深度感
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 25);
            camera.lookAt(0, TREE_HEIGHT / 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // 环境光和点光源
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffd700, 1, 50);
            pointLight.position.set(5, 10, 5);
            scene.add(pointLight);

            createStarfield();
            createSnow();
            createTreeParticlesShader();
            createDecorations();

            scene.add(treeGroup);
            treeGroup.add(decorationsGroup);
            scene.add(floatingPhotosGroup);
            // 默认添加一张占位图作为幻灯片
            addPlaceholderSlide();

            window.addEventListener('resize', onWindowResize);
        }

        // --- 创建背景星空 ---
        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 5000; i++) {
                vertices.push(THREE.MathUtils.randFloatSpread(200)); // x
                vertices.push(THREE.MathUtils.randFloatSpread(200)); // y
                vertices.push(THREE.MathUtils.randFloatSpread(200)); // z
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0x888888, size: 0.5 });
            starField = new THREE.Points(geometry, material);
            scene.add(starField);
        }

        // --- 创建动态雪花 ---
        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const velocities = [];
            for (let i = 0; i < 1000; i++) {
                vertices.push(THREE.MathUtils.randFloatSpread(100)); // x
                vertices.push(THREE.MathUtils.randFloatSpread(100)); // y
                vertices.push(THREE.MathUtils.randFloatSpread(100)); // z
                velocities.push(0, -Math.random() * 0.5 - 0.1, 0); // 向下速度
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
            
            // 使用圆形纹理让雪花更柔和
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            const material = new THREE.PointsMaterial({ 
                size: 1.5, 
                map: sprite, 
                blending: THREE.AdditiveBlending, 
                depthTest: false, 
                transparent: true,
                opacity: 0.7
            });

            snowParticles = new THREE.Points(geometry, material);
            scene.add(snowParticles);
        }

        // --- 创建核心粒子圣诞树 (使用 Shader) ---
        function createTreeParticlesShader() {
            const geometry = new THREE.BufferGeometry();
            const positionsA = []; // 树形态位置
            const positionsB = []; // 分散形态位置
            const colors = [];
            const sizes = [];

            const colorPalette = [
                new THREE.Color(0xff0000), // 红
                new THREE.Color(0xffd700), // 金
                new THREE.Color(0x00ff00), // 绿
                new THREE.Color(0xffffff)  // 白点缀
            ];

            for (let i = 0; i < TOTAL_TREE_PARTICLES; i++) {
                // --- 状态A: 圆锥螺旋树 ---
                const linkRatio = i / TOTAL_TREE_PARTICLES; // 0 到 1
                const y = linkRatio * TREE_HEIGHT;
                const radius = (1 - linkRatio) * TREE_RADIUS;
                const angle = linkRatio * Math.PI * 2 * 15; // 15圈螺旋
                // 增加一些随机扰动让树看起来更自然
                const x = Math.cos(angle) * radius + (Math.random() -0.5) * 0.5;
                const z = Math.sin(angle) * radius + (Math.random() -0.5) * 0.5;
                positionsA.push(x, y, z);

                // --- 状态B: 屏幕中心爆炸/幻灯片模式 ---
                // 粒子散开并稍微向屏幕前方移动
                const spread = 30;
                positionsB.push(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread + TREE_HEIGHT / 2,
                    (Math.random() - 0.5) * spread + 10 // 稍微靠前
                );

                // 颜色分配：偏重红金绿
                let colorIndex = Math.floor(Math.random() * colorPalette.length);
                if (Math.random() > 0.8) colorIndex = 3; // 少量白色
                const color = colorPalette[colorIndex];
                colors.push(color.r, color.g, color.b);

                sizes.push(Math.random() * 1.5 + 0.5);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positionsA, 3));
            geometry.setAttribute('targetPosition', new THREE.Float32BufferAttribute(positionsB, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 3));

            // --- 自定义 Shader ---
            treeUniforms = {
                uTime: { value: 0 },
                uMixFactor: { value: 0.0 }, // 控制聚散的因子 (0=树, 1=散)
                uTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: treeUniforms,
                vertexShader: `
                    uniform float uTime;
                    uniform float uMixFactor;
                    attribute vec3 targetPosition;
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;

                    // 简单的噪声函数
                    float random (vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);
                    }

                    void main() {
                        vColor = color;
                        
                        // 在两个状态之间插值
                        vec3 newPosition = mix(position, targetPosition, uMixFactor);
                        
                        // 添加一些基于时间的波动，增加魔法感
                        float noise = random(position.xy) * sin(uTime * 2.0 + position.z) * 0.5;
                        if(uMixFactor < 0.5) {
                             newPosition.x += noise;
                             newPosition.z += noise;
                        }

                        vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
                        
                        // 散开时粒子变大，模拟幻灯片窗口
                        float finalSize = size * (1.0 + uMixFactor * 5.0); 
                        gl_PointSize = finalSize * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4(vColor, 1.0) * texture2D(uTexture, gl_PointCoord);
                        if (gl_FragColor.a < 0.1) discard; // 透明剔除
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            treeParticles = new THREE.Points(geometry, material);
            treeGroup.add(treeParticles);
            // 将树稍微向下移，使其底部在中心
            treeGroup.position.y = -TREE_HEIGHT / 2; 
        }

        // --- 创建装饰品 (铃铛/礼物 - 简化为几何体) ---
        function createDecorations() {
            const boxGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const sphereGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const giftMat = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100 });
            const bellMat = new THREE.MeshPhongMaterial({ color: 0xffd700, shininess: 150 });

            for (let i = 0; i < 30; i++) {
                let mesh;
                if (i % 2 === 0) {
                    mesh = new THREE.Mesh(boxGeo, giftMat); // 礼物
                } else {
                    mesh = new THREE.Mesh(sphereGeo, bellMat); // 铃铛
                }
                // 随机分布在树的体积内
                const ratio = Math.random();
                const y = ratio * TREE_HEIGHT;
                const radius = (1 - ratio) * TREE_RADIUS * (0.8 + Math.random()*0.4);
                const angle = Math.random() * Math.PI * 2;
                mesh.position.set(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
                // 随机旋转
                mesh.rotation.set(Math.random(), Math.random(), Math.random());
                decorationsGroup.add(mesh);
            }
        }

        // --- MediaPipe Hands 设置 ---
        function setupMediaPipe() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                })
                .catch(err => {
                    document.getElementById('loading').textContent = "无法访问摄像头，请检查权限。";
                    console.error(err);
                });
        }

        // --- 处理手势识别结果 ---
        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. 计算手掌中心用于旋转 (使用腕关节0和中指根部9的平均值)
                const palmCenterX = (landmarks[0].x + landmarks[9].x) / 2;
                const palmCenterY = (landmarks[0].y + landmarks[9].y) / 2;
                // 将 0-1 的坐标映射到旋转角度 (-PI 到 PI)
                handRotationTarget.y = (palmCenterX - 0.5) * Math.PI * 2; 
                handRotationTarget.x = (palmCenterY - 0.5) * Math.PI * 0.5;

                // 2. 检测五指张开 (简单的距离判断)
                const wrist = landmarks[0];
                const tips = [4, 8, 12, 16, 20]; // 指尖索引
                let extendedFingers = 0;
                tips.forEach(tipIndex => {
                    const tip = landmarks[tipIndex];
                    const distance = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    // 阈值需要根据实际情况微调，这里取经验值
                    if (distance > 0.25) extendedFingers++;
                });

                // 如果5根手指都伸展，则认为张开
                isHandOpen = (extendedFingers >= 4); // 允许一点误差，4根以上算张开
            } else {
                // 没有检测到手，缓慢复位
                isHandOpen = false;
                handRotationTarget.x *= 0.95;
                handRotationTarget.y *= 0.95;
            }
        }

        // --- 键盘事件和照片导入 ---
        function setupKeyboard() {
            const fileInput = document.getElementById('file-input');
            
            window.addEventListener('keydown', (e) => {
                if (['1', '2', '3', '4', '5'].includes(e.key)) {
                    fileInput.click();
                }
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        const texture = new THREE.Texture(img);
                        img.onload = () => { texture.needsUpdate = true; };
                        addFloatingPhoto(texture);
                        slideshowTextures.push(texture); // 加入幻灯片队列
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        function addPlaceholderSlide() {
             // 加载一个透明的占位纹理，避免幻灯片逻辑出错
             slideshowTextures.push(new THREE.TextureLoader().load('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'));
        }

        function addFloatingPhoto(texture) {
            // 创建一个相框
            const geometry = new THREE.PlaneGeometry(4, 3);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const photoMesh = new THREE.Mesh(geometry, material);
            
            // 随机位置，围绕树
            const angle = Math.random() * Math.PI * 2;
            const radius = TREE_RADIUS + 5 + Math.random() * 5;
            photoMesh.position.set(
                Math.cos(angle) * radius,
                Math.random() * TREE_HEIGHT,
                Math.sin(angle) * radius
            );
            
            // 随机旋转速度数据
            photoMesh.userData = {
                rotSpeedX: (Math.random() - 0.5) * 0.02,
                rotSpeedY: (Math.random() - 0.5) * 0.02,
                orbitSpeed: (Math.random() + 0.1) * 0.005,
                orbitAngle: angle,
                orbitRadius: radius
            };

            floatingPhotosGroup.add(photoMesh);
        }
        
        // --- 更新幻灯片 (在粒子散开时显示) ---
        // 注意：这里的实现不是真的让每个粒子变成照片，而是当粒子散开时，
        // 在屏幕中心显示一个主要的幻灯片平面，因为数万个纹理切换性能无法支撑。
        // 上面的 Shader 中粒子变大是为了配合这种视觉错觉。
        let slideshowPlane;
        function updateSlideshow(deltaTime) {
            if (isHandOpen && slideshowTextures.length > 0) {
                if (!slideshowPlane) {
                    const geo = new THREE.PlaneGeometry(16, 9); // 16:9 比例
                    const mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
                    slideshowPlane = new THREE.Mesh(geo, mat);
                    slideshowPlane.position.set(0, TREE_HEIGHT/2, 5); // 放在树中心前方
                    scene.add(slideshowPlane);
                }

                // 幻灯片切换逻辑
                if (clock.elapsedTime - lastSlideChangeTime > 2.0) { // 每2秒切换
                    currentSlideIndex = (currentSlideIndex + 1) % slideshowTextures.length;
                    slideshowPlane.material.map = slideshowTextures[currentSlideIndex];
                    slideshowPlane.material.needsUpdate = true;
                    lastSlideChangeTime = clock.elapsedTime;
                }
                 // 淡入
                slideshowPlane.material.opacity = THREE.MathUtils.lerp(slideshowPlane.material.opacity, 1, deltaTime * 2);

            } else if (slideshowPlane) {
                // 淡出并移除
                slideshowPlane.material.opacity = THREE.MathUtils.lerp(slideshowPlane.material.opacity, 0, deltaTime * 5);
                if (slideshowPlane.material.opacity < 0.05) {
                    scene.remove(slideshowPlane);
                    slideshowPlane = null;
                }
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 主动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // 1. 更新 Shader Uniforms
            treeUniforms.uTime.value = elapsedTime;
            // 平滑过渡 mixFactor
            const targetMix = isHandOpen ? 1.0 : 0.0;
            treeUniforms.uMixFactor.value = THREE.MathUtils.lerp(treeUniforms.uMixFactor.value, targetMix, deltaTime * 3);

            // 2. 更新树的旋转 (跟随手势，带阻尼)
            treeGroup.rotation.y += (handRotationTarget.y - treeGroup.rotation.y) * deltaTime * 2;
            treeGroup.rotation.x += (handRotationTarget.x - treeGroup.rotation.x) * deltaTime * 2;

            // 3. 更新雪花
            const snowPositions = snowParticles.geometry.attributes.position.array;
            const snowVelocities = snowParticles.geometry.attributes.velocity.array;
            for (let i = 0; i < snowPositions.length; i += 3) {
                snowPositions[i + 1] += snowVelocities[i + 1]; // y轴移动
                if (snowPositions[i + 1] < -50) {
                    snowPositions[i + 1] = 50; // 循环回到顶部
                }
            }
            snowParticles.geometry.attributes.position.needsUpdate = true;
            snowParticles.rotation.y += deltaTime * 0.1; // 整体缓慢旋转

            // 4. 更新漂浮照片
            floatingPhotosGroup.children.forEach(photo => {
                photo.rotation.x += photo.userData.rotSpeedX;
                photo.rotation.y += photo.userData.rotSpeedY;
                // 环绕运动
                photo.userData.orbitAngle += photo.userData.orbitSpeed;
                photo.position.x = Math.cos(photo.userData.orbitAngle) * photo.userData.orbitRadius;
                photo.position.z = Math.sin(photo.userData.orbitAngle) * photo.userData.orbitRadius;
            });
            
            // 5. 更新装饰品 (使其在树散开时也轻微散开)
            decorationsGroup.children.forEach(deco => {
                const initialPos = deco.position.clone();
                const targetPos = initialPos.clone().multiplyScalar(1.5 + Math.random()); // 散开目标
                deco.position.lerpVectors(initialPos, targetPos, treeUniforms.uMixFactor.value * 0.1); // 轻微跟随
                deco.rotation.y += deltaTime * 0.5;
            });

            // 6. 更新幻灯片逻辑
            updateSlideshow(deltaTime);

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
